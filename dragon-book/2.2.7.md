<h1 align="center">Exercises for Section 2.2</h1>

**Exercise 2.2.1:** Consider the context-free grammar

<p align="center">S &rarr; S S + | S S * | a</p>

a) Show how the string **aa+a*** can be generated by this grammar.

b) Construct a parse tree for this string.

c) What language does this grammar generate? Justify your answer.

**Answer:**

a)
```
S   → SS*
    → SS+S*
    → aa+S*
    → aa+a*
```

Alternating **S** with **a** and backwards, we got: **(aa+)a*** from **aa***

b) 

![Parse Tree](https://user-images.githubusercontent.com/52632898/148651428-92c510fa-6c63-44ba-b584-c45440ecbf33.png)

c) It is a postfix expression consisting of a's, plus (summation sign) and, star (multiply sign).
This grammar generates a language that consists of the possible arithmetic operations,
involving 'a' with the use of only the '+' and ' * ' operations with the postfix notation.
The only non-terminal symbol in the grammar is 'a' and it replaces all occurrences of 'S',
leaving only a statement consisting of a series of a's and the '+' and ' * ' operations.

---

**Exercise 2.2.2:** What language is generated by the following grammars? In each case justify your answer.

a) S → 0 S 1 | 0 1

b) S → + S S | - S S | a

c) S → S ( S ) S | ε

d) S → a S b S | b S a S | ε

e) S → a | S + S | S S | S * | ( S )

**Answer:**

a) L = {0<sup>n</sup>1<sup>n</sup> | n >= 1}. This grammar generates a language consisting of a series of 0's and 1's coming in middle of a '01'.
There are to be at least two 0's and two 1's and there is the same number of 0's as 1's.

b) This grammar generates a language that consists of the possible arithmetic operations,
involving 'a' as a non-terminal symbol with the use of only the '+' and '-' operations by the prefix notation.

c) This grammar generates a language that consists of a series of adjacent and nested, matched pairs of parentheses, including ε.

d) This grammar generates a language that consists of an equal number of a's and b's in no particular order, including ε.

e) This grammar generates a language that consists of the possible arithmetic operations involving 'a' with the only use of '+' and '*' operations,
and sets of matched parentheses. It may involve both postfix and infix notations.

---

**Exercise 2.2.3:** Which of the grammars in Exercise 2.2.2 are ambiguous?

**Answer:**

a) Not an ambiguous grammar. As it has a terminal string, it can be defined by only one parse tree.

b) Not an ambiguous grammar. As it has a terminal string, it can be defined by only one parse tree.

c) An ambiguous grammer, we can define **()()** as more than one parse tree:

![parseTree1](https://user-images.githubusercontent.com/52632898/148659171-c6d601cc-158d-4705-90bb-17441c42dec5.png)
![parseTree2](https://user-images.githubusercontent.com/52632898/148659177-020fc103-3491-4c47-8184-f63ea778de97.png)

d) An ambiguous grammar, we can define **abab** as more than one parse tree:

![parseTree1](https://user-images.githubusercontent.com/52632898/148659567-50341f86-df8e-4c83-99a1-896c77667742.png)
![parseTree2](https://user-images.githubusercontent.com/52632898/148659570-b14d3504-36f5-4cd8-9258-42e8f5c3a814.png)

_*Notice that the epsilon in the final string of the parse tree is not considerable, as it is an empty string._ 

e) An ambiguous grammar, we can define **a+(a)a*** as more than one parse tree:

![parseTree1](https://user-images.githubusercontent.com/52632898/148660411-e2fddfd1-0069-4e3b-b0d6-2aba611c2d20.png)
![parseTree2](https://user-images.githubusercontent.com/52632898/148660413-563aa7ea-1255-42df-a25a-c72015c8d0d2.png)

---

**Exercise 2.2.4:** Construct unambiguous context-free grammars for each of the following languages.
In each case show that your grammar is correct.

a) Arithmetic expressions in postfix notation.

b) Left-associative lists of identifiers separated by commas.

c) Right-associative lists of identifiers separated by commas.

d) Arithmetic expressions of integers and identifiers with the four binary operators +, -, *, /.

! e) Add unary plus and minus to the arithmetic operators of (d).

**Answer**

a) ```expr → expr expr op | num```

b) ```list → list , id | id```

c) ```list → id , list | id```

d) 
```
expr → expr + term | expr - term | term
term → term * factor | term / factor | factor
factor → num | id | (expr)
```

e)
```
expr → expr + term | expr - term | term
term → term * unary | term / unary | unary
unary → + factor | - factor | factor
factor → num | id | (expr)
```

---

**Exercise 2.2.5:**

a) Show that all binary strings generated by the following grammar have values divisible by 3.
_Hint:_ Use induction on the number of nodes in a parse tree.

<p align="center">num &rarr; 11 | 1001 | num 0 | num num</p>

b)  Does the grammar generate all binary strings with values divisible by 3?

**Answer**

a) 
* (11)<sub>2</sub> = (3)<sub>10</sub> is divisible by 3
* (1001)<sub>2</sub> = (9)<sub>10</sub> is divisible by 3
if 'num' is divisible by 3 then:
* 'num 0' is 2 * (3x) = 3 * (2x), which is divisible by 3.
* 'num num' is (3x) * 2<sup>z</sup> + 3y = 3 * (2<sup>z</sup> * x + y), which is also divisible by 3.


Another proof:
Clearly, any string derived from this grammar can be considered to be a sequence consisting of 11's and 1001's,
where each sequence of those two is possibly suffixed with a 0. Let n be the set of positions where 11 is placed. 11 is said to be at position i if the rightmost '1' is at position i;
where i starts at 0 and grows from least significant to most significant bit. And, let m be the equivalent set of positions of 1001.

The sum of any string produced by the grammar would be: 
sum = Σ<sub>n</sub> (2<sup>1</sup> + 2<sup>0</sup>) * 2 <sup>n</sup> + Σ<sub>m</sub> (2<sup>3</sup> + 2<sup>0</sup>) * 2<sup>m</sup>
    = Σ<sub>n</sub> 3 * 2 <sup>n</sup> + Σ<sub>m</sub> 9 * 2<sup>m</sup>

And, that is divisible by 3.

b) No. Consider the string 10101, which is divisible by 3, but cannot be derived from the grammar.
Notice that every number, generated by this grammar has an even number of 1, while 10101 has an odd number of 1.

---

**Exercise 2.2.6:** Construct a context-free grammar for roman numerals.

**Answer:**

We can categorize the single roman numerals into 4 groups:
I, II, III | I V | V, V I, V II, V III | I X
then get the production:
```
digits → digit | I V | V digit | I X
digit → I | I I | I I I
```
And we can find a simple way to map roman numerals to Arabic numerals, for example: 
```
XII → X + II → 10 + 2 → 12
CXCIX → C + XC + IX → 100 + 90 + 9 → 199
MDCCCLXXX → M + DCCC + LXXX → 1000 + 800 + 80 → 1880
```
Via the upper two rules, we can derive the production:

```
roman → thousand hundred ten digit
thousand → M | M M | M M M | ε
hundreds → hundred | C D | D hundred | C M
hundred → C | C C | C C C  | ε
tens → ten | X L | L ten | X C
ten → X | X X | X X X | ε
digits → digit | I V | V digit | I X
digit → I | I I | I I I
```

_*Notice that we just consider a subset of roman numerals which is less than 4k, for the sake of simplification._
